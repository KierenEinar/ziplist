//// Created by CF on 2021/5/24.//#include <stdio.h>#include <memory.h>#include <limits.h>#include <stdint.h>#include <string.h>#include <stdlib.h>#define ZIPLIST_END 255#define ZIPLIST_BIG_PREVLEN 254#define ZIPLIST_HEADER_SIEZ ((sizeof(uint32_t)*2)+(sizeof(uint16_t)))#define ZIPLIST_END_SIZE (sizeof(uint8_t))#define zlbytes(zl) (*((uint32_t*)zl))#define zltail(zl) (*((uint32_t*)(zl+sizeof(uint32_t))))#define zllen(zl) (*((uint32_t*)(zl+sizeof(uint32_t)*2)))#define zlend(zl) (*((uint32_t*)(zl+sizeof(uint32_t)*2+sizeof(uint16_t))))#define intrev32ifbe(v) (v)#define ZIPLIST_ENTRY_TAIL(zl) (zl+intrev32ifbe(zltail(zl)))#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {           \    if ((ptr[0]) < ZIPLIST_BIG_PREVLEN) {                       \        (prevlensize) = 1;                                      \    } else {                                                    \        (prevlensize) = 5;                                      \    }                                                           \} while(0);//#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {//    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize)//    if (prevlensize == 1) {//        prevlen = ptr[0];//    } else {////        prevlen = ptr[1]////    }//} while(0);// ---------------------API---------------------------// 实例化一个ziplistunsigned char *ziplistNew (void) {    unsigned int bytes = ZIPLIST_HEADER_SIEZ+ZIPLIST_END_SIZE;    unsigned char *zl =malloc(bytes);    zlbytes(zl) = intrev32ifbe(bytes); // 设置bytes    zltail(zl)  = intrev32ifbe(ZIPLIST_HEADER_SIEZ); // 设置tail offset    zllen(zl)   = intrev32ifbe(0); // 设置len    zlend(zl)   = intrev32ifbe(ZIPLIST_END); // 设置end    return zl;}// 插入unsigned char *__ziplstInsert (unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {    // 先获取prevlensize    /* zlentry定义        a. [prevlensize] => 1bytes或者5vytes, 当是1个bytes的时候, 存储0-253, 当是5个bytes的时候, 第一个bytes恒为254, 剩下4个bytes存prevlen, 大端顺序存储        b. [lensize] => 1bytes的encoding, 1bytes或者4bytes的len              [encoding, len] => 00 xxxxxx 类型是str, 剩下的6个bit存字符串的长度, 大端序                         => 01 pppppp qqqqqqqq, 14个bit为字符串的长度, 大端序                         => 10 pppppp qqqqqqqq ssssssss ffffffff 32个bit为字符串的长度, 大端序                         => 0xc0 | 0 << 4, 2bytes int16 11000000                         => 0xc0 | 1 << 4, 4bytes int32 11010000                         => 0xc0 | 2 << 4, 8bytes int64 11100000                         => 0xc0 | 3 << 4, 24bytes      11110000                         => 0xfe, 1bytes, 低4位存储数字        c. 后边接 content    */    unsigned int prevlensize, prevlen;    // 如果是插入队尾    if (p[0] == ZIPLIST_END) {        // 判断ziplist是否空元素, 若是的话, prevlensize=1, 值是0        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);        if (ptail[0] != ZIPLIST_END) {            // 获取ptail的lensize和len        }    }    return NULL;}